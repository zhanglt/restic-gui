# Restic GUI 详细设计文档

**项目名称：** Restic GUI
**版本：** 1.1
**编写日期：** 2025-10-24
**文档状态：** 实现完成版
**实现状态：** 所有核心类已实现，共75个文件，约11,300行代码

---

## 1. 引言

### 1.1 文档目的

本文档是Restic GUI项目的详细设计文档，详细描述系统中每个类的接口、方法、属性、数据流和交互关系。本文档为开发人员提供编码实现的详细指南。

### 1.2 适用范围

本文档适用于开发工程师和代码审查人员。

### 1.3 参考文档

- 《Restic GUI 需求规格说明书》v1.1
- 《Restic GUI 概要设计文档》v1.1
- Qt 5.14 API文档

---

## 2. 项目结构

### 2.1 目录组织

```
restic-gui/
├── src/
│   ├── main.cpp                 # 程序入口
│   ├── core/                    # 核心业务逻辑（6个管理器）
│   │   ├── ResticWrapper.h/cpp
│   │   ├── RepositoryManager.h/cpp
│   │   ├── BackupManager.h/cpp
│   │   ├── RestoreManager.h/cpp
│   │   ├── SnapshotManager.h/cpp
│   │   └── SchedulerManager.h/cpp
│   ├── ui/                      # 界面层
│   │   ├── MainWindow.h/cpp/.ui          # 主窗口（.ui文件）
│   │   ├── pages/                        # 6个主页面（全部使用.ui）
│   │   │   ├── HomePage.h/cpp/.ui
│   │   │   ├── RepositoryPage.h/cpp/.ui
│   │   │   ├── BackupPage.h/cpp/.ui
│   │   │   ├── SnapshotPage.h/cpp/.ui
│   │   │   ├── RestorePage.h/cpp/.ui
│   │   │   └── StatsPage.h/cpp/.ui
│   │   ├── wizards/                      # 向导（纯代码）
│   │   │   └── CreateRepoWizard.h/cpp    # 5步向导
│   │   ├── dialogs/                      # 对话框
│   │   │   ├── ProgressDialog.h/cpp/.ui       # .ui文件
│   │   │   ├── SettingsDialog.h/cpp/.ui       # .ui文件
│   │   │   ├── PruneOptionsDialog.h/cpp/.ui   # .ui文件
│   │   │   ├── CreateTaskDialog.h/cpp         # 纯代码
│   │   │   └── SnapshotBrowserDialog.h/cpp    # 纯代码
│   │   └── widgets/                      # 自定义控件（纯代码）
│   │       ├── SnapshotListWidget.h/cpp
│   │       └── FileTreeWidget.h/cpp
│   ├── models/                  # 数据模型（8个结构体）
│   │   ├── Repository.h/cpp
│   │   ├── BackupTask.h/cpp
│   │   ├── Schedule.h/cpp
│   │   ├── Snapshot.h/cpp
│   │   ├── FileInfo.h/cpp
│   │   ├── BackupResult.h/cpp
│   │   ├── RestoreOptions.h/cpp
│   │   └── RepoStats.h/cpp
│   ├── data/                    # 数据访问层（4个管理器）
│   │   ├── DatabaseManager.h/cpp
│   │   ├── ConfigManager.h/cpp
│   │   ├── PasswordManager.h/cpp
│   │   └── CacheManager.h/cpp
│   └── utils/                   # 工具类（4个）
│       ├── Logger.h/cpp
│       ├── CryptoUtil.h/cpp
│       ├── FileSystemUtil.h/cpp
│       └── NetworkUtil.h/cpp
├── resources/
│   ├── restic-gui.qrc           # 资源清单
│   ├── icons/                   # 图标资源
│   ├── sql/                     # 数据库初始化脚本
│   ├── styles/                  # UI 样式表
│   └── translations/            # 翻译文件
│       └── restic_gui_zh_CN.ts
├── build/                       # 构建输出（自动生成）
│   ├── obj/                     # 目标文件
│   ├── moc/                     # Meta-Object Compiler 输出
│   ├── ui/                      # Generated ui_XXX.h 文件
│   └── rcc/                     # 资源编译输出
├── bin/                         # 可执行文件输出
│   └── restic-gui.exe           # 编译后的应用
├── docs/                        # 设计文档
├── restic-gui.pro               # qmake 项目文件
├── README.md                    # 项目说明
└── CLAUDE.md                    # Claude 项目指导
```

**实际文件统计：**
- .h 文件：36 个
- .cpp 文件：29 个
- .ui 文件：10 个
- 总计：75 个文件，约 11,300 行代码

### 2.2 命名空间

```cpp
namespace ResticGUI {
    namespace Core {
        // 核心业务类
    }

    namespace UI {
        // 界面类
    }

    namespace Models {
        // 数据模型
    }

    namespace Data {
        // 数据访问
    }

    namespace Utils {
        // 工具类
    }
}
```

---

## 3. 核心业务逻辑层详细设计

### 3.1 ResticWrapper类

**文件：** `src/core/ResticWrapper.h`, `src/core/ResticWrapper.cpp`

**职责：** 封装所有restic命令行调用，提供统一的接口和错误处理

#### 3.1.1 类定义

```cpp
#ifndef RESTICWRAPPER_H
#define RESTICWRAPPER_H

#include <QObject>
#include <QProcess>
#include <QJsonDocument>
#include <QJsonObject>
#include <QJsonArray>
#include "models/Repository.h"
#include "models/Snapshot.h"
#include "models/FileInfo.h"
#include "models/BackupTask.h"
#include "models/BackupResult.h"
#include "models/RestoreOptions.h"
#include "models/RepoStats.h"

namespace ResticGUI {
namespace Core {

class ResticWrapper : public QObject
{
    Q_OBJECT

public:
    explicit ResticWrapper(QObject *parent = nullptr);
    ~ResticWrapper();

    // ===== 仓库操作 =====

    /**
     * @brief 初始化新仓库
     * @param repo 仓库配置信息
     * @param password 加密密码
     * @return 成功返回true
     */
    bool initRepository(const Models::Repository& repo, const QString& password);

    /**
     * @brief 检查仓库完整性
     * @param repo 仓库配置
     * @param readData 是否读取数据块验证（耗时）
     * @return 成功返回true
     */
    bool checkRepository(const Models::Repository& repo, bool readData = false);

    /**
     * @brief 测试仓库连接和密码
     * @param repo 仓库配置
     * @param password 密码
     * @return 成功返回true
     */
    bool testConnection(const Models::Repository& repo, const QString& password);

    // ===== 备份操作 =====

    /**
     * @brief 执行备份任务
     * @param task 备份任务配置
     * @param password 仓库密码
     * @return 备份结果
     */
    Models::BackupResult backup(const Models::BackupTask& task, const QString& password);

    /**
     * @brief 异步执行备份任务
     * @param task 备份任务配置
     * @param password 仓库密码
     */
    void backupAsync(const Models::BackupTask& task, const QString& password);

    /**
     * @brief 取消当前备份操作
     */
    void cancelBackup();

    // ===== 快照操作 =====

    /**
     * @brief 获取仓库中的所有快照
     * @param repo 仓库配置
     * @param password 密码
     * @return 快照列表
     */
    QList<Models::Snapshot> getSnapshots(const Models::Repository& repo,
                                         const QString& password);

    /**
     * @brief 获取快照详细信息
     * @param repo 仓库配置
     * @param password 密码
     * @param snapshotId 快照ID
     * @return 快照详情
     */
    Models::Snapshot getSnapshotDetail(const Models::Repository& repo,
                                       const QString& password,
                                       const QString& snapshotId);

    /**
     * @brief 列出快照中的文件
     * @param repo 仓库配置
     * @param password 密码
     * @param snapshotId 快照ID
     * @return 文件列表
     */
    QList<Models::FileInfo> listFiles(const Models::Repository& repo,
                                      const QString& password,
                                      const QString& snapshotId);

    /**
     * @brief 在快照中查找文件
     * @param repo 仓库配置
     * @param password 密码
     * @param pattern 搜索模式
     * @param snapshotId 快照ID（空表示搜索所有快照）
     * @return 匹配的文件列表
     */
    QList<Models::FileInfo> findFiles(const Models::Repository& repo,
                                      const QString& password,
                                      const QString& pattern,
                                      const QString& snapshotId = QString());

    // ===== 快照管理 =====

    /**
     * @brief 删除指定快照
     * @param repo 仓库配置
     * @param password 密码
     * @param snapshotIds 快照ID列表
     * @return 成功返回true
     */
    bool forgetSnapshots(const Models::Repository& repo,
                        const QString& password,
                        const QStringList& snapshotIds);

    /**
     * @brief 根据策略删除快照
     * @param repo 仓库配置
     * @param password 密码
     * @param policy 保留策略（如--keep-last 10）
     * @return 成功返回true
     */
    bool forgetByPolicy(const Models::Repository& repo,
                       const QString& password,
                       const QString& policy);

    /**
     * @brief 清理仓库（prune）
     * @param repo 仓库配置
     * @param password 密码
     * @return 成功返回true
     */
    bool prune(const Models::Repository& repo, const QString& password);

    /**
     * @brief 为快照添加标签
     * @param repo 仓库配置
     * @param password 密码
     * @param snapshotIds 快照ID列表
     * @param tags 标签列表
     * @return 成功返回true
     */
    bool addTags(const Models::Repository& repo,
                const QString& password,
                const QStringList& snapshotIds,
                const QStringList& tags);

    /**
     * @brief 从快照移除标签
     * @param repo 仓库配置
     * @param password 密码
     * @param snapshotIds 快照ID列表
     * @param tags 标签列表
     * @return 成功返回true
     */
    bool removeTags(const Models::Repository& repo,
                   const QString& password,
                   const QStringList& snapshotIds,
                   const QStringList& tags);

    // ===== 恢复操作 =====

    /**
     * @brief 恢复数据
     * @param repo 仓库配置
     * @param password 密码
     * @param snapshotId 快照ID
     * @param targetPath 恢复目标路径
     * @param options 恢复选项
     * @return 成功返回true
     */
    bool restore(const Models::Repository& repo,
                const QString& password,
                const QString& snapshotId,
                const QString& targetPath,
                const Models::RestoreOptions& options);

    /**
     * @brief 异步恢复数据
     */
    void restoreAsync(const Models::Repository& repo,
                     const QString& password,
                     const QString& snapshotId,
                     const QString& targetPath,
                     const Models::RestoreOptions& options);

    /**
     * @brief 取消当前恢复操作
     */
    void cancelRestore();

    // ===== 统计信息 =====

    /**
     * @brief 获取仓库统计信息
     * @param repo 仓库配置
     * @param password 密码
     * @return 统计信息
     */
    Models::RepoStats getStats(const Models::Repository& repo,
                               const QString& password);

    // ===== 版本信息 =====

    /**
     * @brief 获取restic版本
     * @return 版本字符串
     */
    QString getResticVersion();

signals:
    // 命令执行信号
    void commandStarted(const QString& command);
    void commandOutput(const QString& output);
    void commandError(const QString& error);
    void commandFinished(bool success, const QString& message);

    // 进度信号
    void progressUpdate(int percentage, const QString& status);
    void progressDetails(qint64 filesProcessed, qint64 filesTotal,
                        qint64 bytesProcessed, qint64 bytesTotal,
                        double speed);

    // 备份/恢复完成信号
    void backupFinished(bool success, const Models::BackupResult& result);
    void restoreFinished(bool success, const QString& message);

private slots:
    void onReadyReadStandardOutput();
    void onReadyReadStandardError();
    void onProcessFinished(int exitCode, QProcess::ExitStatus exitStatus);
    void onProcessError(QProcess::ProcessError error);

private:
    // 命令执行
    QProcess* executeCommand(const QStringList& args,
                            const Models::Repository* repo = nullptr,
                            const QString& password = QString());

    QProcess* executeCommandAsync(const QStringList& args,
                                  const Models::Repository* repo = nullptr,
                                  const QString& password = QString());

    // 环境变量设置
    QProcessEnvironment buildEnvironment(const Models::Repository& repo,
                                        const QString& password);

    // 命令构建
    QStringList buildBackupArgs(const Models::BackupTask& task);
    QStringList buildRestoreArgs(const QString& snapshotId,
                                const QString& targetPath,
                                const Models::RestoreOptions& options);

    // 输出解析
    void parseStandardOutput(const QString& output);
    void parseStandardError(const QString& error);
    QJsonDocument parseJsonLine(const QString& line);

    // JSON数据解析
    Models::Snapshot parseSnapshot(const QJsonObject& obj);
    Models::FileInfo parseFileInfo(const QJsonObject& obj);
    Models::BackupResult parseBackupResult(const QJsonObject& obj);
    Models::RepoStats parseStats(const QJsonObject& obj);

    // 进度解析
    void parseProgress(const QJsonObject& obj);

    // 错误处理
    QString translateError(const QString& error);

private:
    QProcess* m_currentProcess;         // 当前进程
    QString m_resticPath;                // restic可执行文件路径
    QByteArray m_outputBuffer;           // 输出缓冲区
    QByteArray m_errorBuffer;            // 错误缓冲区

    // 临时存储（用于异步操作）
    Models::BackupResult m_backupResult;
    bool m_commandSuccess;
};

} // namespace Core
} // namespace ResticGUI

#endif // RESTICWRAPPER_H
```

#### 3.1.2 关键方法实现示例

##### backup方法

```cpp
Models::BackupResult ResticWrapper::backup(const Models::BackupTask& task,
                                           const QString& password)
{
    Models::BackupResult result;
    result.success = false;

    // 构建命令参数
    QStringList args = buildBackupArgs(task);

    // 获取仓库信息
    // 假设task中包含repositoryId，需要通过RepositoryManager获取
    // 这里简化处理，假设task包含完整repo信息
    Models::Repository repo = task.repository;

    // 执行命令
    QProcess* process = executeCommand(args, &repo, password);
    if (!process) {
        result.errorMessage = tr("无法启动restic进程");
        return result;
    }

    // 等待完成（同步）
    if (!process->waitForFinished(-1)) {
        result.errorMessage = tr("备份超时或被中断");
        process->kill();
        process->deleteLater();
        return result;
    }

    // 检查退出码
    if (process->exitCode() != 0) {
        result.errorMessage = QString::fromUtf8(process->readAllStandardError());
        process->deleteLater();
        return result;
    }

    // 解析输出
    QString output = QString::fromUtf8(process->readAllStandardOutput());
    QStringList lines = output.split('\n', Qt::SkipEmptyParts);

    // 查找JSON输出行（summary）
    for (const QString& line : lines) {
        if (line.trimmed().startsWith('{')) {
            QJsonDocument doc = QJsonDocument::fromJson(line.toUtf8());
            if (!doc.isNull() && doc.isObject()) {
                QJsonObject obj = doc.object();
                if (obj.contains("snapshot_id")) {
                    result = parseBackupResult(obj);
                    result.success = true;
                    break;
                }
            }
        }
    }

    process->deleteLater();
    return result;
}
```

##### buildBackupArgs方法

```cpp
QStringList ResticWrapper::buildBackupArgs(const Models::BackupTask& task)
{
    QStringList args;
    args << "backup";

    // 添加源路径
    args << task.sourcePaths;

    // 添加排除规则
    for (const QString& pattern : task.excludePatterns) {
        args << "--exclude" << pattern;
    }

    // 添加标签
    for (const QString& tag : task.tags) {
        args << "--tag" << tag;
    }

    // 主机名
    if (!task.hostname.isEmpty()) {
        args << "--hostname" << task.hostname;
    }

    // JSON输出
    args << "--json";

    // 其他选项
    if (task.options.contains("verbose") && task.options["verbose"].toBool()) {
        args << "--verbose";
    }

    return args;
}
```

##### parseBackupResult方法

```cpp
Models::BackupResult ResticWrapper::parseBackupResult(const QJsonObject& obj)
{
    Models::BackupResult result;

    result.snapshotId = obj["snapshot_id"].toString();

    QJsonObject summary = obj["summary"].toObject();
    result.filesNew = summary["files_new"].toInt();
    result.filesChanged = summary["files_changed"].toInt();
    result.filesUnmodified = summary["files_unmodified"].toInt();

    result.dataAdded = summary["data_added"].toDouble();
    result.dataProcessed = summary["total_bytes_processed"].toDouble();

    result.duration = summary["total_duration"].toDouble();

    return result;
}
```

### 3.2 RepositoryManager类

**文件：** `src/core/RepositoryManager.h`, `src/core/RepositoryManager.cpp`

**职责：** 管理仓库的CRUD操作、连接验证、密码管理

#### 3.2.1 类定义

```cpp
#ifndef REPOSITORYMANAGER_H
#define REPOSITORYMANAGER_H

#include <QObject>
#include <QList>
#include "models/Repository.h"
#include "data/DatabaseManager.h"
#include "data/PasswordManager.h"
#include "core/ResticWrapper.h"

namespace ResticGUI {
namespace Core {

class RepositoryManager : public QObject
{
    Q_OBJECT

public:
    // 单例模式
    static RepositoryManager* instance();

    // 仓库CRUD
    int addRepository(const Models::Repository& repo);
    bool updateRepository(const Models::Repository& repo);
    bool removeRepository(int repoId);
    Models::Repository getRepository(int repoId);
    QList<Models::Repository> getAllRepositories();

    // 默认仓库
    void setDefaultRepository(int repoId);
    Models::Repository getDefaultRepository();

    // 仓库操作
    bool initRepository(Models::Repository& repo, const QString& password);
    bool testConnection(const Models::Repository& repo, const QString& password);
    bool checkRepository(const Models::Repository& repo, bool full = false);

    // 密码管理
    void cachePassword(int repoId, const QString& password, int durationMinutes = 0);
    QString getCachedPassword(int repoId);
    bool hasPassword(int repoId);
    void clearPasswordCache(int repoId = -1);

signals:
    void repositoryAdded(int repoId);
    void repositoryUpdated(int repoId);
    void repositoryRemoved(int repoId);
    void defaultRepositoryChanged(int repoId);

    void checkStarted();
    void checkProgress(int percentage, const QString& status);
    void checkFinished(bool success, const QString& message);

    void connectionTested(bool success, const QString& message);

private:
    explicit RepositoryManager(QObject *parent = nullptr);
    ~RepositoryManager();

    static RepositoryManager* s_instance;

    Data::DatabaseManager* m_db;
    Data::PasswordManager* m_passwordMgr;
    ResticWrapper* m_restic;

    // 缓存
    QMap<int, Models::Repository> m_repoCache;
    int m_defaultRepoId;

    void loadCache();
};

} // namespace Core
} // namespace ResticGUI

#endif // REPOSITORYMANAGER_H
```

#### 3.2.2 关键方法实现

##### addRepository方法

```cpp
int RepositoryManager::addRepository(const Models::Repository& repo)
{
    // 验证参数
    if (repo.name.isEmpty()) {
        qWarning() << "Repository name cannot be empty";
        return -1;
    }

    // 插入数据库
    int repoId = m_db->insertRepository(repo);
    if (repoId < 0) {
        qWarning() << "Failed to insert repository into database";
        return -1;
    }

    // 更新缓存
    Models::Repository newRepo = repo;
    newRepo.id = repoId;
    m_repoCache[repoId] = newRepo;

    // 发出信号
    emit repositoryAdded(repoId);

    return repoId;
}
```

##### testConnection方法

```cpp
bool RepositoryManager::testConnection(const Models::Repository& repo,
                                       const QString& password)
{
    // 尝试列出快照以测试连接
    bool success = m_restic->testConnection(repo, password);

    QString message;
    if (success) {
        message = tr("连接成功");
    } else {
        message = tr("连接失败，请检查配置和密码");
    }

    emit connectionTested(success, message);

    return success;
}
```

### 3.3 BackupManager类

**文件：** `src/core/BackupManager.h`, `src/core/BackupManager.cpp`

**职责：** 管理备份任务的创建、执行、监控和历史记录

#### 3.3.1 类定义

```cpp
#ifndef BACKUPMANAGER_H
#define BACKUPMANAGER_H

#include <QObject>
#include <QMap>
#include "models/BackupTask.h"
#include "models/BackupHistory.h"
#include "models/BackupResult.h"
#include "data/DatabaseManager.h"
#include "core/ResticWrapper.h"
#include "core/RepositoryManager.h"

namespace ResticGUI {
namespace Core {

class BackupManager : public QObject
{
    Q_OBJECT

public:
    static BackupManager* instance();

    // 任务管理
    int createTask(const Models::BackupTask& task);
    bool updateTask(const Models::BackupTask& task);
    bool deleteTask(int taskId);
    Models::BackupTask getTask(int taskId);
    QList<Models::BackupTask> getAllTasks();
    QList<Models::BackupTask> getTasksByRepository(int repoId);

    // 执行备份
    bool executeTask(int taskId, bool async = false);
    void cancelTask(int taskId);

    // 历史记录
    QList<Models::BackupHistory> getHistory(int taskId = -1,
                                           const QDateTime& from = QDateTime(),
                                           const QDateTime& to = QDateTime());
    Models::BackupHistory getHistoryById(int historyId);

    // 当前状态
    bool isTaskRunning(int taskId);
    QList<int> getRunningTasks();

signals:
    void taskCreated(int taskId);
    void taskUpdated(int taskId);
    void taskDeleted(int taskId);

    void backupStarted(int taskId);
    void backupProgress(int taskId, int percentage, const QString& status,
                       qint64 filesProcessed, qint64 filesTotal,
                       qint64 bytesProcessed, qint64 bytesTotal);
    void backupFinished(int taskId, bool success,
                       const Models::BackupResult& result);

private:
    explicit BackupManager(QObject *parent = nullptr);
    ~BackupManager();

    static BackupManager* s_instance;

    Data::DatabaseManager* m_db;
    RepositoryManager* m_repoMgr;
    ResticWrapper* m_restic;

    struct RunningTask {
        int taskId;
        QDateTime startTime;
        ResticWrapper* restic;  // 每个任务独立的wrapper
    };

    QMap<int, RunningTask> m_runningTasks;
    QMap<int, Models::BackupTask> m_taskCache;

    void saveHistory(int taskId, const Models::BackupResult& result,
                    const QDateTime& startTime);
    void connectResticSignals(ResticWrapper* restic, int taskId);
};

} // namespace Core
} // namespace ResticGUI

#endif // BACKUPMANAGER_H
```

#### 3.3.2 executeTask方法

```cpp
bool BackupManager::executeTask(int taskId, bool async)
{
    // 检查任务是否已在运行
    if (isTaskRunning(taskId)) {
        qWarning() << "Task" << taskId << "is already running";
        return false;
    }

    // 获取任务
    Models::BackupTask task = getTask(taskId);
    if (task.id < 0) {
        qWarning() << "Task" << taskId << "not found";
        return false;
    }

    // 获取仓库
    Models::Repository repo = m_repoMgr->getRepository(task.repositoryId);
    if (repo.id < 0) {
        qWarning() << "Repository" << task.repositoryId << "not found";
        return false;
    }

    // 获取密码
    QString password = m_repoMgr->getCachedPassword(repo.id);
    if (password.isEmpty()) {
        // 触发密码输入对话框（通过信号）
        // 这里简化处理，假设已有密码
        qWarning() << "Password not available for repository" << repo.id;
        return false;
    }

    // 创建ResticWrapper实例
    ResticWrapper* restic = new ResticWrapper(this);
    connectResticSignals(restic, taskId);

    // 记录运行状态
    RunningTask running;
    running.taskId = taskId;
    running.startTime = QDateTime::currentDateTime();
    running.restic = restic;
    m_runningTasks[taskId] = running;

    // 发出开始信号
    emit backupStarted(taskId);

    // 执行备份
    if (async) {
        // 异步执行
        task.repository = repo;  // 注入仓库信息
        restic->backupAsync(task, password);
    } else {
        // 同步执行
        task.repository = repo;
        Models::BackupResult result = restic->backup(task, password);

        // 保存历史
        saveHistory(taskId, result, running.startTime);

        // 清理
        m_runningTasks.remove(taskId);
        restic->deleteLater();

        // 发出完成信号
        emit backupFinished(taskId, result.success, result);

        return result.success;
    }

    return true;
}
```

### 3.4 RestoreManager类

**文件：** `src/core/RestoreManager.h`, `src/core/RestoreManager.cpp`

**职责：** 管理数据恢复操作

#### 3.4.1 类定义

```cpp
#ifndef RESTOREMANAGER_H
#define RESTOREMANAGER_H

#include <QObject>
#include <QStandardItemModel>
#include "models/Repository.h"
#include "models/Snapshot.h"
#include "models/FileInfo.h"
#include "models/RestoreOptions.h"
#include "core/ResticWrapper.h"
#include "core/RepositoryManager.h"

namespace ResticGUI {
namespace Core {

// 文件树模型
class FileTreeModel : public QStandardItemModel
{
    Q_OBJECT

public:
    explicit FileTreeModel(QObject *parent = nullptr);

    enum Role {
        FilePathRole = Qt::UserRole + 1,
        FileSizeRole,
        FileTypeRole,
        FileMTimeRole
    };

    void loadFiles(const QList<Models::FileInfo>& files);
    QStringList getSelectedPaths(const QModelIndexList& indexes);

private:
    void buildTree(const QList<Models::FileInfo>& files);
    QStandardItem* findOrCreatePath(const QString& path);
};

class RestoreManager : public QObject
{
    Q_OBJECT

public:
    static RestoreManager* instance();

    // 浏览快照
    FileTreeModel* browseSnapshot(int repoId, const QString& snapshotId);

    // 搜索文件
    QList<Models::FileInfo> findFiles(int repoId,
                                      const QString& pattern,
                                      const QString& snapshotId = QString());

    // 恢复操作
    bool restore(int repoId,
                const QString& snapshotId,
                const QString& targetPath,
                const QStringList& includePaths,
                const Models::RestoreOptions& options,
                bool async = false);

    void cancelRestore();

    // 当前状态
    bool isRestoring();

signals:
    void restoreStarted();
    void restoreProgress(int percentage, const QString& currentFile,
                        qint64 filesProcessed, qint64 filesTotal,
                        qint64 bytesProcessed, qint64 bytesTotal);
    void restoreFinished(bool success, const QString& message);

    void fileTreeReady(FileTreeModel* model);
    void findResultsReady(const QList<Models::FileInfo>& files);

private:
    explicit RestoreManager(QObject *parent = nullptr);
    ~RestoreManager();

    static RestoreManager* s_instance;

    RepositoryManager* m_repoMgr;
    ResticWrapper* m_restic;
    bool m_isRestoring;

    FileTreeModel* m_currentTreeModel;
};

} // namespace Core
} // namespace ResticGUI

#endif // RESTOREMANAGER_H
```

### 3.5 SnapshotManager类

**文件：** `src/core/SnapshotManager.h`, `src/core/SnapshotManager.cpp`

**职责：** 管理快照的查看、删除、清理和标签

#### 3.5.1 类定义

```cpp
#ifndef SNAPSHOTMANAGER_H
#define SNAPSHOTMANAGER_H

#include <QObject>
#include <QList>
#include "models/Snapshot.h"
#include "models/RepoStats.h"
#include "models/ForgetPolicy.h"
#include "data/CacheManager.h"
#include "core/ResticWrapper.h"
#include "core/RepositoryManager.h"

namespace ResticGUI {
namespace Core {

struct SnapshotFilter {
    QString hostname;
    QStringList paths;
    QStringList tags;
    QDateTime from;
    QDateTime to;

    bool matches(const Models::Snapshot& snapshot) const;
};

class SnapshotManager : public QObject
{
    Q_OBJECT

public:
    static SnapshotManager* instance();

    // 查询快照
    QList<Models::Snapshot> getSnapshots(int repoId,
                                         const SnapshotFilter& filter = SnapshotFilter(),
                                         bool useCache = true);
    Models::Snapshot getSnapshotDetail(int repoId, const QString& snapshotId);

    // 刷新缓存
    void refreshSnapshots(int repoId);

    // 删除快照
    bool forgetSnapshots(int repoId, const QStringList& snapshotIds);
    bool forgetByPolicy(int repoId, const Models::ForgetPolicy& policy);

    // 清理仓库
    bool prune(int repoId, bool async = false);

    // 标签管理
    bool addTags(int repoId, const QStringList& snapshotIds,
                const QStringList& tags);
    bool removeTags(int repoId, const QStringList& snapshotIds,
                   const QStringList& tags);

    // 统计信息
    Models::RepoStats getRepoStats(int repoId, bool useCache = true);

signals:
    void snapshotsLoaded(int repoId, const QList<Models::Snapshot>& snapshots);
    void snapshotUpdated(const QString& snapshotId);
    void snapshotsDeleted(const QStringList& snapshotIds);

    void pruneStarted();
    void pruneProgress(int percentage, const QString& status);
    void pruneFinished(bool success, qint64 freedSpace);

    void statsUpdated(int repoId, const Models::RepoStats& stats);

private:
    explicit SnapshotManager(QObject *parent = nullptr);
    ~SnapshotManager();

    static SnapshotManager* s_instance;

    RepositoryManager* m_repoMgr;
    ResticWrapper* m_restic;
    Data::CacheManager* m_cache;

    void updateSnapshotCache(int repoId, const QList<Models::Snapshot>& snapshots);
};

} // namespace Core
} // namespace ResticGUI

#endif // SNAPSHOTMANAGER_H
```

### 3.6 SchedulerManager类

**文件：** `src/core/SchedulerManager.h`, `src/core/SchedulerManager.cpp`

**职责：** 管理定时备份任务的调度和执行

#### 3.6.1 类定义

```cpp
#ifndef SCHEDULERMANAGER_H
#define SCHEDULERMANAGER_H

#include <QObject>
#include <QTimer>
#include <QDateTime>
#include "models/BackupTask.h"
#include "models/Schedule.h"
#include "core/BackupManager.h"

namespace ResticGUI {
namespace Core {

struct NextExecution {
    int taskId;
    QDateTime nextTime;
    QString description;
};

class SchedulerManager : public QObject
{
    Q_OBJECT

public:
    static SchedulerManager* instance();

    // 启动/停止调度器
    void start();
    void stop();
    bool isRunning();

    // 任务调度
    void scheduleTask(int taskId);
    void unscheduleTask(int taskId);
    void updateSchedule(int taskId);

    // 手动触发
    void triggerTask(int taskId);

    // 查询
    QList<NextExecution> getUpcomingExecutions();
    NextExecution getNextExecution(int taskId);

    // 条件检查配置
    void setRequireAC(bool require);
    void setRequireNetwork(bool require);
    void setRequireIdle(bool require);

signals:
    void schedulerStarted();
    void schedulerStopped();

    void taskScheduled(int taskId, const QDateTime& nextTime);
    void taskUnscheduled(int taskId);

    void taskTriggered(int taskId);
    void taskExecuted(int taskId, bool success);

    void conditionsNotMet(int taskId, const QString& reason);

private slots:
    void onTimerTick();
    void onBackupFinished(int taskId, bool success,
                         const Models::BackupResult& result);

private:
    explicit SchedulerManager(QObject *parent = nullptr);
    ~SchedulerManager();

    static SchedulerManager* s_instance;

    BackupManager* m_backupMgr;
    QTimer* m_timer;

    struct ScheduledTaskInfo {
        int taskId;
        Models::Schedule schedule;
        QDateTime lastExecution;
        QDateTime nextExecution;
        int failureCount;
    };

    QMap<int, ScheduledTaskInfo> m_scheduledTasks;

    bool m_requireAC;
    bool m_requireNetwork;
    bool m_requireIdle;

    // 计算下次执行时间
    QDateTime calculateNextExecution(const Models::Schedule& schedule,
                                     const QDateTime& from);

    // 条件检查
    bool checkConditions(int taskId, QString& reason);
    bool isSystemIdle();
    bool isACConnected();
    bool isNetworkAvailable();

    // 加载任务
    void loadScheduledTasks();
};

} // namespace Core
} // namespace ResticGUI

#endif // SCHEDULERMANAGER_H
```

#### 3.6.2 核心方法实现

##### calculateNextExecution方法

```cpp
QDateTime SchedulerManager::calculateNextExecution(
    const Models::Schedule& schedule,
    const QDateTime& from)
{
    QDateTime next = from;

    switch (schedule.type) {
    case Models::Schedule::Hourly:
        // 每小时在整点执行
        next = next.addSecs(3600 - (next.time().minute() * 60 + next.time().second()));
        break;

    case Models::Schedule::Daily:
        // 每天在指定时间执行
        next = QDateTime(next.date(), schedule.time);
        if (next <= from) {
            next = next.addDays(1);
        }
        break;

    case Models::Schedule::Weekly:
        // 每周在指定日期和时间执行
        {
            int currentDayOfWeek = next.date().dayOfWeek();
            int targetDayOfWeek = schedule.dayOfWeek;
            int daysToAdd = (targetDayOfWeek - currentDayOfWeek + 7) % 7;
            if (daysToAdd == 0 && next.time() > schedule.time) {
                daysToAdd = 7;
            }
            next = QDateTime(next.date().addDays(daysToAdd), schedule.time);
        }
        break;

    case Models::Schedule::Monthly:
        // 每月在指定日期和时间执行
        {
            QDate targetDate(next.date().year(), next.date().month(), schedule.dayOfMonth);
            if (!targetDate.isValid() || targetDate < next.date() ||
                (targetDate == next.date() && next.time() > schedule.time)) {
                // 移到下个月
                targetDate = QDate(next.date().year(), next.date().month(), 1)
                            .addMonths(1);
                targetDate = QDate(targetDate.year(), targetDate.month(), schedule.dayOfMonth);
            }
            next = QDateTime(targetDate, schedule.time);
        }
        break;

    case Models::Schedule::Custom:
        // 自定义cron表达式（需要cron解析器）
        // 这里简化处理
        next = parseCron(schedule.cronExpression, from);
        break;

    default:
        return QDateTime();
    }

    return next;
}
```

---

## 4. 数据访问层详细设计

### 4.1 DatabaseManager类

**文件：** `src/data/DatabaseManager.h`, `src/data/DatabaseManager.cpp`

**职责：** 管理SQLite数据库的连接、创建和数据操作

#### 4.1.1 类定义

```cpp
#ifndef DATABASEMANAGER_H
#define DATABASEMANAGER_H

#include <QObject>
#include <QSqlDatabase>
#include <QSqlQuery>
#include "models/Repository.h"
#include "models/BackupTask.h"
#include "models/BackupHistory.h"

namespace ResticGUI {
namespace Data {

class DatabaseManager : public QObject
{
    Q_OBJECT

public:
    static DatabaseManager* instance();

    // 初始化
    bool initialize(const QString& dbPath = QString());
    void close();

    // 仓库操作
    int insertRepository(const Models::Repository& repo);
    bool updateRepository(const Models::Repository& repo);
    bool deleteRepository(int repoId);
    Models::Repository getRepository(int repoId);
    QList<Models::Repository> getAllRepositories();

    // 备份任务操作
    int insertBackupTask(const Models::BackupTask& task);
    bool updateBackupTask(const Models::BackupTask& task);
    bool deleteBackupTask(int taskId);
    Models::BackupTask getBackupTask(int taskId);
    QList<Models::BackupTask> getAllBackupTasks();
    QList<Models::BackupTask> getBackupTasksByRepository(int repoId);

    // 备份历史操作
    int insertBackupHistory(const Models::BackupHistory& history);
    QList<Models::BackupHistory> getBackupHistory(
        int taskId = -1,
        const QDateTime& from = QDateTime(),
        const QDateTime& to = QDateTime());
    Models::BackupHistory getBackupHistoryById(int historyId);
    bool deleteOldHistory(int daysToKeep);

    // 设置操作
    void setSetting(const QString& key, const QVariant& value);
    QVariant getSetting(const QString& key, const QVariant& defaultValue = QVariant());

    // 数据库维护
    bool vacuum();
    bool backup(const QString& backupPath);

signals:
    void databaseError(const QString& error);

private:
    explicit DatabaseManager(QObject *parent = nullptr);
    ~DatabaseManager();

    static DatabaseManager* s_instance;

    QSqlDatabase m_db;
    QString m_dbPath;

    bool createTables();
    bool executeQuery(const QString& sql, const QVariantList& params = QVariantList());
    QSqlQuery prepareQuery(const QString& sql);

    // 辅助方法
    Models::Repository repositoryFromQuery(QSqlQuery& query);
    Models::BackupTask backupTaskFromQuery(QSqlQuery& query);
    Models::BackupHistory backupHistoryFromQuery(QSqlQuery& query);
};

} // namespace Data
} // namespace ResticGUI

#endif // DATABASEMANAGER_H
```

#### 4.1.2 createTables方法

```cpp
bool DatabaseManager::createTables()
{
    QStringList sqls;

    // repositories表
    sqls << R"(
        CREATE TABLE IF NOT EXISTS repositories (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            name TEXT NOT NULL,
            type TEXT NOT NULL,
            path TEXT NOT NULL,
            config TEXT,
            password_hash TEXT,
            created_at TEXT NOT NULL,
            last_backup TEXT,
            is_default INTEGER DEFAULT 0
        )
    )";

    // backup_tasks表
    sqls << R"(
        CREATE TABLE IF NOT EXISTS backup_tasks (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            name TEXT NOT NULL,
            repository_id INTEGER NOT NULL,
            source_paths TEXT NOT NULL,
            exclude_patterns TEXT,
            tags TEXT,
            hostname TEXT,
            options TEXT,
            schedule_type INTEGER DEFAULT 0,
            schedule_config TEXT,
            enabled INTEGER DEFAULT 1,
            created_at TEXT NOT NULL,
            updated_at TEXT NOT NULL,
            FOREIGN KEY (repository_id) REFERENCES repositories(id)
                ON DELETE CASCADE
        )
    )";

    // backup_history表
    sqls << R"(
        CREATE TABLE IF NOT EXISTS backup_history (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            task_id INTEGER NOT NULL,
            snapshot_id TEXT,
            start_time TEXT NOT NULL,
            end_time TEXT NOT NULL,
            success INTEGER NOT NULL,
            files_new INTEGER DEFAULT 0,
            files_changed INTEGER DEFAULT 0,
            files_unmodified INTEGER DEFAULT 0,
            data_added INTEGER DEFAULT 0,
            data_processed INTEGER DEFAULT 0,
            duration INTEGER DEFAULT 0,
            error_message TEXT,
            FOREIGN KEY (task_id) REFERENCES backup_tasks(id)
                ON DELETE CASCADE
        )
    )";

    // settings表
    sqls << R"(
        CREATE TABLE IF NOT EXISTS settings (
            key TEXT PRIMARY KEY,
            value TEXT
        )
    )";

    // password_store表（可选，加密存储密码）
    sqls << R"(
        CREATE TABLE IF NOT EXISTS password_store (
            repository_id INTEGER PRIMARY KEY,
            encrypted_password TEXT NOT NULL,
            FOREIGN KEY (repository_id) REFERENCES repositories(id)
                ON DELETE CASCADE
        )
    )";

    // 执行所有SQL
    for (const QString& sql : sqls) {
        QSqlQuery query(m_db);
        if (!query.exec(sql)) {
            qCritical() << "Failed to create table:" << query.lastError().text();
            return false;
        }
    }

    return true;
}
```

### 4.2 ConfigManager类

**文件：** `src/data/ConfigManager.h`, `src/data/ConfigManager.cpp`

**职责：** 管理应用程序配置（基于QSettings）

```cpp
#ifndef CONFIGMANAGER_H
#define CONFIGMANAGER_H

#include <QSettings>
#include <QObject>

namespace ResticGUI {
namespace Data {

class ConfigManager : public QObject
{
    Q_OBJECT

public:
    static ConfigManager* instance();

    // 基本配置
    QString resticPath();
    void setResticPath(const QString& path);

    int defaultRepositoryId();
    void setDefaultRepositoryId(int repoId);

    // 界面配置
    QString theme();
    void setTheme(const QString& theme);

    int fontSize();
    void setFontSize(int size);

    bool startMinimized();
    void setStartMinimized(bool value);

    bool closeToTray();
    void setCloseToTray(bool value);

    // 备份配置
    int backupThreads();
    void setBackupThreads(int threads);

    int networkTimeout();
    void setNetworkTimeout(int seconds);

    int retryCount();
    void setRetryCount(int count);

    bool notifyOnComplete();
    void setNotifyOnComplete(bool value);

    // 窗口状态
    QByteArray windowGeometry();
    void setWindowGeometry(const QByteArray& geometry);

    QByteArray windowState();
    void setWindowState(const QByteArray& state);

    // 日志配置
    int logLevel();
    void setLogLevel(int level);

    QString logPath();
    void setLogPath(const QString& path);

    // 密码缓存
    int passwordCacheDuration();
    void setPasswordCacheDuration(int minutes);

signals:
    void configChanged(const QString& key);

private:
    explicit ConfigManager(QObject *parent = nullptr);
    ~ConfigManager();

    static ConfigManager* s_instance;
    QSettings* m_settings;

    QVariant getValue(const QString& key, const QVariant& defaultValue);
    void setValue(const QString& key, const QVariant& value);
};

} // namespace Data
} // namespace ResticGUI

#endif // CONFIGMANAGER_H
```

### 4.3 PasswordManager类

**文件：** `src/data/PasswordManager.h`, `src/data/PasswordManager.cpp`

**职责：** 管理仓库密码的缓存和加密存储

```cpp
#ifndef PASSWORDMANAGER_H
#define PASSWORDMANAGER_H

#include <QObject>
#include <QMap>
#include <QDateTime>
#include "DatabaseManager.h"
#include "utils/CryptoUtil.h"

namespace ResticGUI {
namespace Data {

class PasswordManager : public QObject
{
    Q_OBJECT

public:
    static PasswordManager* instance();

    // 内存缓存
    void cachePassword(int repoId, const QString& password, int durationMinutes = 0);
    QString getCachedPassword(int repoId);
    bool hasCachedPassword(int repoId);
    void clearCache(int repoId = -1);

    // 持久化存储（加密）
    bool storePassword(int repoId, const QString& password);
    QString retrievePassword(int repoId);
    bool hasStoredPassword(int repoId);
    bool deleteStoredPassword(int repoId);

signals:
    void passwordExpired(int repoId);

private:
    explicit PasswordManager(QObject *parent = nullptr);
    ~PasswordManager();

    static PasswordManager* s_instance;

    struct CachedPassword {
        QString password;
        QDateTime expiryTime;
    };

    QMap<int, CachedPassword> m_cache;
    DatabaseManager* m_db;
    Utils::CryptoUtil* m_crypto;

    void startCleanupTimer();
    void cleanupExpired();

    QString getEncryptionKey();
};

} // namespace Data
} // namespace ResticGUI

#endif // PASSWORDMANAGER_H
```

---

## 5. 数据模型详细设计

### 5.1 Repository模型

**文件：** `src/models/Repository.h`, `src/models/Repository.cpp`

```cpp
#ifndef REPOSITORY_H
#define REPOSITORY_H

#include <QString>
#include <QDateTime>
#include <QVariantMap>

namespace ResticGUI {
namespace Models {

struct Repository
{
    int id = -1;
    QString name;
    QString type;  // local, sftp, s3, rest, azure, gs, b2
    QString path;
    QVariantMap config;  // 特定于类型的配置
    QString passwordHash;  // 可选的加密存储密码
    QDateTime createdAt;
    QDateTime lastBackup;
    bool isDefault = false;

    // 辅助方法
    QString displayName() const;
    QString typeDisplayName() const;
    bool isValid() const;

    // 序列化
    QVariantMap toVariantMap() const;
    static Repository fromVariantMap(const QVariantMap& map);

    // 配置构建
    QString buildConnectionString() const;
};

} // namespace Models
} // namespace ResticGUI

#endif // REPOSITORY_H
```

### 5.2 BackupTask模型

**文件：** `src/models/BackupTask.h`

```cpp
#ifndef BACKUPTASK_H
#define BACKUPTASK_H

#include <QString>
#include <QStringList>
#include <QDateTime>
#include <QVariantMap>
#include "Repository.h"
#include "Schedule.h"

namespace ResticGUI {
namespace Models {

struct BackupTask
{
    int id = -1;
    QString name;
    int repositoryId = -1;
    QStringList sourcePaths;
    QStringList excludePatterns;
    QStringList tags;
    QString hostname;
    QVariantMap options;
    Schedule schedule;
    bool enabled = true;
    QDateTime createdAt;
    QDateTime updatedAt;

    // 运行时填充
    Repository repository;

    // 辅助方法
    bool isValid() const;
    QString description() const;

    // 序列化
    QVariantMap toVariantMap() const;
    static BackupTask fromVariantMap(const QVariantMap& map);
};

} // namespace Models
} // namespace ResticGUI

#endif // BACKUPTASK_H
```

### 5.3 Schedule模型

**文件：** `src/models/Schedule.h`

```cpp
#ifndef SCHEDULE_H
#define SCHEDULE_H

#include <QString>
#include <QTime>
#include <QVariantMap>

namespace ResticGUI {
namespace Models {

struct Schedule
{
    enum Type {
        None = 0,
        Hourly,
        Daily,
        Weekly,
        Monthly,
        Custom
    };

    Type type = None;
    QTime time = QTime(0, 0);
    int dayOfWeek = 0;  // 0=周日, 1=周一, ...
    int dayOfMonth = 1;
    QString cronExpression;

    // 条件
    bool requireAC = false;
    bool requireNetwork = false;
    bool requireIdle = false;

    // 辅助方法
    bool isValid() const;
    QString description() const;

    // 序列化
    QVariantMap toVariantMap() const;
    static Schedule fromVariantMap(const QVariantMap& map);
};

} // namespace Models
} // namespace ResticGUI

#endif // SCHEDULE_H
```

### 5.4 其他数据模型

类似地定义以下模型：
- **Snapshot：** 快照信息
- **FileInfo：** 文件信息
- **BackupResult：** 备份结果
- **BackupHistory：** 备份历史
- **RestoreOptions：** 恢复选项
- **RepoStats：** 仓库统计
- **ForgetPolicy：** 快照保留策略

---

## 6. 界面层详细设计

### 6.1 MainWindow

**文件：** `src/ui/MainWindow.h`, `src/ui/MainWindow.cpp`, `src/ui/MainWindow.ui`

**职责：** 主窗口，包含导航和内容区域

#### 6.1.1 类定义

```cpp
#ifndef MAINWINDOW_H
#define MAINWINDOW_H

#include <QMainWindow>
#include <QStackedWidget>
#include <QListWidget>
#include <QLabel>

namespace Ui {
class MainWindow;
}

namespace ResticGUI {
namespace UI {

class MainWindow : public QMainWindow
{
    Q_OBJECT

public:
    explicit MainWindow(QWidget *parent = nullptr);
    ~MainWindow();

protected:
    void closeEvent(QCloseEvent *event) override;

private slots:
    void onNavigationChanged(int index);
    void onCreateRepository();
    void onCreateBackupTask();
    void onShowSettings();
    void onAbout();

    void updateStatusBar();

private:
    Ui::MainWindow *ui;

    // 页面
    QWidget* m_homePage;
    QWidget* m_repositoryPage;
    QWidget* m_backupPage;
    QWidget* m_snapshotPage;
    QWidget* m_restorePage;
    QWidget* m_statsPage;

    // 状态栏
    QLabel* m_statusRepoLabel;
    QLabel* m_statusLastBackupLabel;

    void setupUI();
    void setupPages();
    void setupConnections();
    void setupTrayIcon();

    void loadWindowState();
    void saveWindowState();
};

} // namespace UI
} // namespace ResticGUI

#endif // MAINWINDOW_H
```

### 6.2 BackupWizard

**文件：** `src/ui/wizards/BackupWizard.h`, `src/ui/wizards/BackupWizard.cpp`

**职责：** 备份任务创建向导

```cpp
#ifndef BACKUPWIZARD_H
#define BACKUPWIZARD_H

#include <QWizard>
#include "models/BackupTask.h"

namespace ResticGUI {
namespace UI {

class BackupWizard : public QWizard
{
    Q_OBJECT

public:
    explicit BackupWizard(QWidget *parent = nullptr);
    ~BackupWizard();

    Models::BackupTask getBackupTask() const;

private:
    Models::BackupTask m_task;
};

// 向导页面
class BackupWizardPageBasic : public QWizardPage
{
    Q_OBJECT
public:
    explicit BackupWizardPageBasic(QWidget *parent = nullptr);
    void initializePage() override;
    bool validatePage() override;
};

class BackupWizardPageSource : public QWizardPage
{
    Q_OBJECT
public:
    explicit BackupWizardPageSource(QWidget *parent = nullptr);
    void initializePage() override;
private slots:
    void onAddFolder();
    void onAddFile();
    void onRemove();
};

class BackupWizardPageExclude : public QWizardPage
{
    Q_OBJECT
public:
    explicit BackupWizardPageExclude(QWidget *parent = nullptr);
private slots:
    void onAddPattern();
    void onRemovePattern();
};

class BackupWizardPageSchedule : public QWizardPage
{
    Q_OBJECT
public:
    explicit BackupWizardPageSchedule(QWidget *parent = nullptr);
    void initializePage() override;
private slots:
    void onScheduleTypeChanged(int index);
};

class BackupWizardPageConfirm : public QWizardPage
{
    Q_OBJECT
public:
    explicit BackupWizardPageConfirm(QWidget *parent = nullptr);
    void initializePage() override;
};

} // namespace UI
} // namespace ResticGUI

#endif // BACKUPWIZARD_H
```

---

## 7. 工具类详细设计

### 7.1 Logger类

**文件：** `src/utils/Logger.h`, `src/utils/Logger.cpp`

**职责：** 日志记录和管理

```cpp
#ifndef LOGGER_H
#define LOGGER_H

#include <QObject>
#include <QFile>
#include <QTextStream>
#include <QMutex>

namespace ResticGUI {
namespace Utils {

class Logger : public QObject
{
    Q_OBJECT

public:
    enum Level {
        Debug = 0,
        Info,
        Warning,
        Error,
        Critical
    };

    static Logger* instance();

    void setLogFile(const QString& filePath);
    void setLevel(Level level);

    void debug(const QString& message);
    void info(const QString& message);
    void warning(const QString& message);
    void error(const QString& message);
    void critical(const QString& message);

    void log(Level level, const QString& message);

    // Qt消息处理器
    static void messageHandler(QtMsgType type,
                              const QMessageLogContext &context,
                              const QString &msg);

signals:
    void logMessage(int level, const QString& message);

private:
    explicit Logger(QObject *parent = nullptr);
    ~Logger();

    static Logger* s_instance;

    QFile m_logFile;
    QTextStream m_logStream;
    Level m_level;
    QMutex m_mutex;

    QString levelToString(Level level);
    void writeToFile(const QString& message);
};

// 便捷宏
#define LOG_DEBUG(msg) ResticGUI::Utils::Logger::instance()->debug(msg)
#define LOG_INFO(msg) ResticGUI::Utils::Logger::instance()->info(msg)
#define LOG_WARNING(msg) ResticGUI::Utils::Logger::instance()->warning(msg)
#define LOG_ERROR(msg) ResticGUI::Utils::Logger::instance()->error(msg)
#define LOG_CRITICAL(msg) ResticGUI::Utils::Logger::instance()->critical(msg)

} // namespace Utils
} // namespace ResticGUI

#endif // LOGGER_H
```

### 7.2 CryptoUtil类

**文件：** `src/utils/CryptoUtil.h`, `src/utils/CryptoUtil.cpp`

**职责：** 加密和解密工具

```cpp
#ifndef CRYPTOUTIL_H
#define CRYPTOUTIL_H

#include <QString>
#include <QByteArray>

namespace ResticGUI {
namespace Utils {

class CryptoUtil
{
public:
    // AES-256加密
    static QString encrypt(const QString& plaintext, const QString& key);
    static QString decrypt(const QString& ciphertext, const QString& key);

    // 密钥派生
    static QByteArray deriveKey(const QString& password, const QByteArray& salt);

    // 哈希
    static QString sha256(const QString& data);

    // 随机生成
    static QString generateRandomKey(int length = 32);
    static QByteArray generateSalt(int length = 16);

    // 系统密钥库（平台相关）
    static bool isSystemKeychainAvailable();
    static bool storeInKeychain(const QString& service,
                               const QString& account,
                               const QString& password);
    static QString retrieveFromKeychain(const QString& service,
                                       const QString& account);

private:
    CryptoUtil() = delete;
};

} // namespace Utils
} // namespace ResticGUI

#endif // CRYPTOUTIL_H
```

---

## 8. 关键流程时序图

### 8.1 备份任务执行流程

```
用户      MainWindow    BackupManager   ResticWrapper   restic进程
 |            |              |               |               |
 |--点击"立即备份"->|           |               |               |
 |            |--executeTask()->              |               |
 |            |              |--验证任务       |               |
 |            |              |--获取仓库密码    |               |
 |            |              |--创建Restic实例  |               |
 |            |              |                |--执行backup--->|
 |            |              |<--backupStarted--|              |
 |            |<--进度更新----|<--progressUpdate-|<--JSON输出---|
 |<--更新进度条|              |                 |               |
 |            |              |                 |<--完成--------|
 |            |              |<--backupFinished-|               |
 |            |<--显示结果----|                 |               |
 |<--提示成功--|              |--保存历史------>|               |
```

### 8.2 快照浏览流程

```
用户      RestorePage   RestoreManager  ResticWrapper   restic进程
 |            |              |               |               |
 |--选择快照-->|              |               |               |
 |            |--browseSnapshot()->          |               |
 |            |              |--获取密码      |               |
 |            |              |               |--执行ls------->|
 |            |              |               |<--JSON输出-----|
 |            |              |<--文件列表-----|               |
 |            |              |--构建文件树    |               |
 |            |<--FileTreeModel|              |               |
 |<--显示树----|              |               |               |
```

---

## 9. 错误处理详细设计

### 9.1 错误类型定义

```cpp
namespace ResticGUI {

enum class ErrorType {
    None,
    Authentication,     // 认证错误（密码错误）
    Network,           // 网络错误
    FileSystem,        // 文件系统错误
    Configuration,     // 配置错误
    ProcessCrash,      // restic进程崩溃
    Unknown            // 未知错误
};

struct Error {
    ErrorType type;
    QString message;
    QString details;
    QString suggestedAction;

    QString toString() const;
};

} // namespace ResticGUI
```

### 9.2 错误处理策略

| 错误类型 | 处理策略 | 用户提示 |
|---------|---------|---------|
| Authentication | 清除密码缓存，要求重新输入 | "密码错误，请重新输入" |
| Network | 自动重试3次，失败后提示用户 | "网络连接失败，请检查网络设置" |
| FileSystem | 显示详细错误，建议检查权限 | "无法访问文件：{path}，请检查权限" |
| Configuration | 高亮错误配置项，提供修复建议 | "配置错误：{error}，建议：{suggestion}" |
| ProcessCrash | 记录日志，清理资源，通知用户 | "备份进程异常退出，请查看日志" |

---

## 10. 性能优化详细设计

### 10.1 缓存策略

```cpp
class CacheManager {
public:
    // 缓存策略
    enum CachePolicy {
        NoCache,           // 不缓存
        MemoryCache,       // 仅内存缓存
        PersistentCache    // 持久化缓存
    };

    // 设置缓存策略和过期时间
    void setCachePolicy(const QString& key, CachePolicy policy, int ttlSeconds);

    // 获取/设置缓存
    QVariant get(const QString& key);
    void set(const QString& key, const QVariant& value);

    // 缓存失效
    void invalidate(const QString& key);
    void invalidateAll();

private:
    struct CacheEntry {
        QVariant value;
        QDateTime expiry;
        CachePolicy policy;
    };

    QMap<QString, CacheEntry> m_memoryCache;
    QSqlDatabase m_persistentCache;
};
```

**缓存策略应用：**
- **快照列表：** MemoryCache, TTL=5分钟
- **仓库统计：** MemoryCache, TTL=10分钟
- **文件树：** MemoryCache, TTL=临时（窗口关闭失效）

### 10.2 异步加载

```cpp
// 使用QtConcurrent进行异步加载
QFuture<QList<Snapshot>> future = QtConcurrent::run([this, repoId]() {
    return m_restic->getSnapshots(repoId);
});

// 监控完成
QFutureWatcher<QList<Snapshot>>* watcher = new QFutureWatcher<QList<Snapshot>>(this);
connect(watcher, &QFutureWatcher::finished, [this, watcher]() {
    QList<Snapshot> snapshots = watcher->result();
    emit snapshotsLoaded(snapshots);
    watcher->deleteLater();
});
watcher->setFuture(future);
```

---

## 11. 测试设计

### 11.1 单元测试

使用Qt Test框架编写单元测试：

```cpp
class TestResticWrapper : public QObject
{
    Q_OBJECT

private slots:
    void initTestCase();    // 测试前初始化
    void cleanupTestCase(); // 测试后清理

    void testInitRepository();
    void testBackup();
    void testRestore();
    void testSnapshots();

private:
    ResticWrapper* m_restic;
    Repository m_testRepo;
};
```

### 11.2 集成测试

测试完整的业务流程：

1. 创建仓库
2. 创建备份任务
3. 执行备份
4. 列出快照
5. 恢复数据
6. 删除快照
7. 清理仓库

---

## 12. 部署设计

### 12.1 Windows部署

```
ResticGUI-1.0-Setup.exe
├── 安装程序
├── 包含Qt运行库
├── 可选包含restic.exe
└── 创建开始菜单和桌面快捷方式
```

### 12.2 Linux部署

**AppImage方式：**
```bash
ResticGUI-1.0-x86_64.AppImage
# 包含所有依赖，无需安装
```

**deb包方式：**
```
restic-gui_1.0-1_amd64.deb
# 依赖：libqt5widgets5, libqt5sql5-sqlite
```

---

**文档结束**

本详细设计文档涵盖了Restic GUI项目的所有核心类、接口、数据流和交互方式。开发人员可以根据此文档进行编码实现。
